分库分表后 跨节点关联查询 join 问题
切分之前，系统中很多列表和详情页所需的数据可以通过 sql join 来完成。而切分之后，数据可能分布在不同的节点上，此时 join 带来的问题就比较麻烦了，考虑到性能，尽量避免使用 join 查询。

<!-- TOC -->

- [全局表](#全局表)
- [json法字段冗余](#json法字段冗余)
- [数据组装 两次查询](#数据组装-两次查询)
- [ER 分片 局部join](#er-分片-局部join)
- [统计分析，可以再做个合库](#统计分析可以再做个合库)

<!-- /TOC -->

解决这个问题的一些方法：

# 全局表

全局表，也可看做是"数据字典表"，就是系统中所有模块都可能依赖的一些表，为了避免跨库 join 查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。

# json法字段冗余

一种典型的反范式设计，利用空间换时间，为了性能而避免 join 查询。例如：订单表保存 userId 时候，也将 userName 冗余保存一份，这样查询订单详情时就不需要再去查询"买家 user 表"了。

但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证，就像上面订单表的例子，买家修改了 userName 后，是否需要在历史订单中同步更新呢？这也要结合实际业务场景进行考虑。

# 数据组装 两次查询

在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。

# ER 分片 局部join

关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能较好的避免跨分片 join 问题。在 1:1 或 1:n 的情况下，通常按照主表的 ID 主键切分。如下图所示：


算是join也尽量实现落到同一个子库中的数据表进行join，即同一用户的相关数据表落到相同的子库中。这也是目前多数成熟的中间件都支持的场景，比如Mycat，Gaea，他们称之为ER分片。Sharding-JDBC虽然支持跨库跨表查询，但性能非常差，它会遍历取所有相关的子库表，然后聚合，最后算出笛卡尔积。所以尽量避免这种做法。

# 统计分析，可以再做个合库
如果还有其他更多的所有数据的Join联查操作，比如要统计分析，可以再做个合库（我们就是这么干的，就是为了给数据组使用
json db mgdb useage

<!-- TOC -->

- [一个完整的业务模块。](#一个完整的业务模块)
- [room member关联。尽可能不要搞关联表](#room-member关联尽可能不要搞关联表)
- [room 改名了怎么办](#room-改名了怎么办)
- [位置运算符更新单个嵌套json字段](#位置运算符更新单个嵌套json字段)
- [建模应该更喜欢嵌入而不是引用](#建模应该更喜欢嵌入而不是引用)
- [嵌套还是独立coll](#嵌套还是独立coll)
  - [尽可能嵌入](#尽可能嵌入)
  - [扩展引用模式](#扩展引用模式)
  - [无限列表 或需要独立访问情况下，需要单独coll](#无限列表-或需要独立访问情况下需要单独coll)
  - [混合模式](#混合模式)

<!-- /TOC -->
# 一个完整的业务模块。
然而因为BSON文档的存储方式，使平常的开发的思维模式有所变更。举个栗子，传统用关系型数据库，订单模块就会分主订单表和订单明细表，创建订单就会用事务同时添加两表的数据，查找订单也会通过两表关联查询出来。但是使用MongoDB，主订单表与其明细，将会以一个完整的对象保存为文档。

　　也因为不支持事务、表关联的原因，它更加适合用作于一个完整的业务模块。


# room member关联。尽可能不要搞关联表
room里面mem太多。。
所以还是member里面设置room列表比较好。。
内部字段互相冗余关联即可。。
也可以根据roomid查询所有mem。。类似全文索引倒排索引

# room 改名了怎么办

可以在mem里面保存当时的roomname

如果改名了，可以根据 room的过去名字改名。。有曾用名表来记录room

类似shyiji life d exmpl

# 位置运算符更新单个嵌套json字段

您甚至可以使用位置运算符更新单个地址：

> db.user.update(    
    {_id: 111111,    
    “addresses.label”: “Home”},    
    {$set: {“addresses.$.street”: “112 Elm Street”}}    
    )

# 建模应该更喜欢嵌入而不是引用
嵌入式文档是存储相关数据（尤其是定期一起访问的数据）的一种高效且干净的方式。通常，在为 MongoDB 设计模式时，默认情况下应该首选嵌入，并且仅在值得时才使用引用和应用程序端或数据库端联接。给定工作负载检索单个文档并拥有所需所有数据的频率越高，应用程序的性能就越一致

# 嵌套还是独立coll

## 尽可能嵌入

## 扩展引用模式
另一种混合情况称为扩展引用。它有点像子集模式，因为它针对定期访问的少量信息进行了优化，以存储在需要它的文档上。在这种情况下，当一个文档引用其自己的集合中的另一个文档时，使用它而不是列表，但也存储该另一个文档中的某些字段以便于访问。

例：

> db.movie.findOne({_id: 444444})
    
{    
    _id: 444444,    
    title: “One Flew Over the Cuckoo's Nest”,    
    studio_id: 999999,    
    studio_name: “Fantasy Films”    
}

如您所见，studio_id被存储，因此您可以查找有关制作电影的工作室的更多信息，但工作室的名称也复制到此文档中以便于显示。请注意，如果要从定期更改的文档嵌入信息，则需要记住在文档更改时更新已复制该信息的文档。

## 无限列表 或需要独立访问情况下，需要单独coll
## 混合模式

主文档也保留少量子集合。。。方便一起展示
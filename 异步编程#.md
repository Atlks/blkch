异步编程#
因此对于此工作内容（IO），我们在 Linux 上有了 epoll/io_uring 技术，在 Windows 上有了 IOCP 技术用以实现异步 IO 操作。

（这里插句题外话，吐槽一句，Linux 终于知道从 Windows 抄作业了。先前的 epoll 对比 IOCP 简直不能打，被 IOCP 全面打压，io_uring 出来了才好不容易能追上 IOCP，不过 IOCP 从 Windows Vista 时代开始每一代都有很大的优化，io_uring 能不能追得上还有待商榷）

这类 API 有一个共同的特性就是，在操作 IO 的时候，调用方控制权被让出，等待 IO 操作完成之后恢复先前的上下文，重新被调度继续运行。


当然，这里说的是操作系统的异步 IO 实现方式，以便于读者对异步这个行为本身进行理解，和 .NET 中的异步还是有区别，Task 本身和操作系统也没什么关系
\

Task.Run#
由于 .NET 是允许有多个线程的，因此也提供了 Task.Run 这个方法，允许我们将 CPU bound 的任务放在上述的线程池之中的某个线程上执行，并且允许我们将该负载作为一个 Task 进行管理，仅在这一点才和多线程的采用线程池的编程比较像。

对于浏览器环境（v8），这个时候是完全没有多线程这一说的，因此你开的新的 Promise 其实是后面利用事件循环机制，将该微任务以异步的方式执行


这时有人要问了：“我在 Task.Run 里面套了好几层 Task.Run，可是为什么层数深了之后里面的不执行了呢?” 这是因为上面所说的线程池被耗尽了，后面的 Task 还在排着队等待被调度。


自己封装异步逻辑#
了解了上面的东西之后，相信对 .NET 中的异步机制应该理解得差不多了，可以看出来这一套是名副其实的 coroutine，并且在实现上是 stackless 的。至于有的人说的什么状态机什么的，只是实现过程中利用的手段而已，并不是什么重要的东西

.NET 的异步和线程密不可分，但是和多线程编程方式和思想是有本质不同的，也希望大家不要将异步和多线程混淆了，而这有联系也有区别
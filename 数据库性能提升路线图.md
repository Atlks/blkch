数据库性能提升路线图  单机情况下

开源节流 ，重点在节流

按照修改复杂度计算

<!-- TOC -->

- [少量修改代码](#少量修改代码)
  - [使用更高性能db  pgsql  mariadb](#使用更高性能db--pgsql--mariadb)
  - [多业务剥离多实例 去除事务机制。。去除部分join](#多业务剥离多实例-去除事务机制去除部分join)
- [io密集 vs cpu密集](#io密集-vs-cpu密集)
  - [1. 压缩数据 提升数据库性能](#1-压缩数据-提升数据库性能)
  - [2. 减少数据库体积到30g全部放入内存中可以](#2-减少数据库体积到30g全部放入内存中可以)
- [中级修改代码](#中级修改代码)
  - [数据迁移 按照uid分库分表](#数据迁移-按照uid分库分表)
  - [做read cach 80%是read](#做read-cach-80是read)
  - [mq rds写入cache](#mq-rds写入cache)
- [大量修改代码](#大量修改代码)
  - [去除join](#去除join)
  - [使用冗余机制json代替join关系。。](#使用冗余机制json代替join关系)
  - [部分业务迁移到mongodb](#部分业务迁移到mongodb)
  - [边缘计算 尽可能客户端计算](#边缘计算-尽可能客户端计算)
  - [业务逻辑js化  将工作负载从服务器端转移到客户端。](#业务逻辑js化--将工作负载从服务器端转移到客户端)

<!-- /TOC -->

# 少量修改代码

上云服务器 更高性能

## 使用更高性能db  pgsql  mariadb

## 多业务剥离多实例 去除事务机制。。去除部分join

# io密集 vs cpu密集

## 1. 压缩数据 提升数据库性能
数据少了占用体积也少，方便内存加载
不要普通压缩，只是减少了io体积，磁盘占用。内存中啊还是原样展开的。

## 2. 减少数据库体积到30g全部放入内存中可以

# 中级修改代码



## 数据迁移 按照uid分库分表
按照userid 分块，使用sqlite模式分库分表

一个应用使用SQLite时，它的功能直接被集成在其中，应用会直接访问包含数据的文件（即SQLite数据库）,而不是通过一些端口（port, socket）来交互。感谢这种底层技术，这使SQLite变得非常快速和高效，并且十分强大。
相当于管道技术，起码提升30%--50%

## 做read cach 80%是read
使用rds mongodb做read cach,mybatis二级cache等。

## mq rds写入cache 
使用mq rds写入cache ，使用rds mongodb 剥离索引在外部，mgdb也存储数据，减少回表。db只有主键索引



# 大量修改代码

## 去除join

## 使用冗余机制json代替join关系。。

## 部分业务迁移到mongodb

## 边缘计算 尽可能客户端计算
 Jamstack 站点不使用传统的 CMS 或站点构建器，而是拆分代码 （JavaScript）、站点基础结构 （API） 和内容（标记）。这些都将在解耦的架构中处理，并在服务器端和客户端之间明确划分。事实上，构建 Jamstack 网站和应用程序背后的主要思想是将尽可能多的负载从服务器推到客户端上。通过这样做，它大大减少了发送到服务器的请求数量，从而消除了服务器处理请求并将其发送回客户端所带来的大量等待时间。

 ## 业务逻辑js化  将工作负载从服务器端转移到客户端。



